
Λειτουργικά Συστήματα

Εργασία 1 
ΑΜ : 1115201700007
Ον/μο : Αρβανίτης Κωνσταντίνος

ΣΗΜΑΝΤΙΚΟ!!!!!!!!!!!!!!!!!!!!!!

1)Δεν έχω καλέσει free() για τις 4 malloc ππου έχω κάνει , διότι έπαιρνα συνέχεια segmentation fault . 
Προσπάθησα να το λύσω αλλά δεν προλάβαινα λόγω χρόνου .

2)Χρησιμοποίησα κάποιες sleep(1) γιατί υπήρξαν φορές που αντί να τρέξει το παιδί συνέχιζε σε άλλο σημείο το πρόγραμμα. 

Επεξήγηση προγράμματος : 

Αρχικά όλο το πρόγραμμα έχει υλοποιηθεί σε ένα αρχείο καθώς δεν ήταν υποχρεωτική η χρήση κάποιας exec για τα παιδιά-διεργασίες .

Έχω υλοποιήσει μία συνάρτηση που μετράει τις γραμμές που έχει το το .txt αρχείο .

Καλούμε malloc() για να δεσμεύσουμε δυναμικά buffers 100 χαρακτήρων(Max characters) που θα χρησιμοποιήσει το shared memory.

Όσο αναφορά τις παραμέτρους της main , για να αποφύγουμε λάθη μετά απο -f ακολουθεί το όνομα του αρχείου , 
μετά από -k ακολουθεί ο αριθμός των παιδιών που δημιουργούνται και τέλος μετά από -n ακολουθεί ο αριθμός δοσοληψιών .

Για τον ορισμό του semaphore χρησιμοποιώ την συνάρτηση (mmap()) για να μοιράσω μέσω mapping το semaphore σε parent και child processes, 
(επειδη το POSIX semaphore είναι on-the-stack-struct δεν θα έχει την ίδια τιμή σε πατέρα και παιδί).

Έχω χρησιμοπποιήσει 1 semaphore και 2 shared memory , έλυσα την άσκηση με 1 semaphore και δεν νομίζω οτι χρειαζόντουσαν παραπάνω και 
έφτιαξα 2 shared memory ένα για να γράφει ο πατέρας και να διαβάζει το παιδί και ενα για το αντίστροφο.

Η βασική λειτουργία του προγράμματος είναι η for που τερματίζει όταν δημιουργηθούν K παιδιά.
Η fork βρίσκεται μέσα στην if , αν επιστρέψει 0 βρισκόμαστε στο παιδί , ακολουθεί μια for που τερματίζει όταν γίνουν N δοσοληψίες.
Καλείται η srand() με seed getpid() για να παιρνούμε τυχαίες γραμμές από παιδί σε παιδί(αν βάζαμε time(NULL) στο κάθε παιδί θα ζήταγε τις ίδιες γραμμές).

Το παιδί καλεί την shm_get() και shm_at() για να πάρει το shared memory και να γράψει πάνω σε αυτό ώστε να το διαβάσει ο parent , θέτουμε την μεταβλητή wd
στην οποία θα γράψουμε την τυχαία γραμμή που ζητάει για να να διαβαστεί από το parent processe , τελός το παιδί καλεί την sem_post , ξυπνάει τον πατέρα , καλεί την gettimeofday για να πάρουμε τον χρόνο που έγινε το αίτημα στον πατέρα και μπλοκάρει
καλώντας την sem_wait() .

Όταν ο parent process γράψει την γραμμή που ζήτησε το παιδί , το παιδί ξυπνάει καλεί την shm_get με το key_parent ως argument και την shm_at με shm_parent ως argument
για να διαβάσει την γραμμή που έγραψε ο parent .

Τέλος , το παιδί καλεί την gettimeofday για δεύτερη φορά καθώς έχει ικανοποιηθεί το αίτημα του , αφαιρεί την 2η κλήση της gettimeofday από την 1η
εκτυπώνει την γραμμή που πήρε από το parent process και τερματίζει με exit(0) , για να μην δημιουργηθουν παραπάνω παιδιά από την επόμενη κλήση της for .

Όσο αναφορά τον πατέρα περιμένει με την κλήση της sem_wait() να ζητήσει το παιδί την γραμμή που θέλει και μετά να ξεκινήσει ξυπνώντας με την κλήση
της sem_post() από το παιδί .

Αφού ξυπνήσει ο πατέρας καλεί την shm_get() με argument key_child και την shm_at() με argument shm_child για να μπορεί να διαβάσει τον αριθμό που ζήτησε το παιδί , 
κάνει rd = shm_child και η γραμμή βρίσκεται στο rd .

Κάνει μία while loop διαβάζοντας μία μία τις γραμμές του αρχείου με την fgets() , κρατάει έναν counter και όταν το counter είναι ίσο με την γραμμή που ζητήθηκε ,
αντιγράφει την γραμμή σε μια μεταβλητή το loop σταματάει με break .

Τέλος , καλεί την shm_get με argument key_parent και την shm_at() με argument shm_parent κάνει την wd ίση με shm_parent γράφει την γραμμή στο wd και ξυπνάει το παιδί
καλώντας την sem_post().










